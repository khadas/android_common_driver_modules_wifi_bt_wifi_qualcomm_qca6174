diff -Nur bt_usb_driver/bt_usb_main.c bt_usb_driver-new/bt_usb_main.c
--- bt_usb_driver/bt_usb_main.c	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/bt_usb_main.c	2019-04-09 16:55:43.205036978 +0800
@@ -126,7 +126,11 @@
 };
 
 #define BT_USB_MAJOR 0
+
+#ifdef BT_USB_DEBUG
 static int callcount;
+#endif
+
 static int bt_usb_major = BT_USB_MAJOR;
 static bt_usb_instance_t *instances = NULL;
 static struct semaphore inst_sem;
@@ -139,26 +143,21 @@
     int i;
 
     idx = 0;
+	memset(buffer,0x0,sizeof(buffer));
 
+	printk("\n");
     for(i=0;i<len;i++)
     {
-        idx+=sprintf(&buffer[idx],"0x%02x ",data[i]);
-
-        if (((i+1)%16) == 0)
-        {
-            printk("%s\n",buffer);
-            idx=0;
-        }
-    }
+		printk("%2x ", data[i]);
 
-    if (idx)
-    {
-        printk("%s\n",buffer);
     }
+	printk("\n");
 }
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+static ssize_t bt_usb_readv(struct kiocb *kiocbp, struct iov_iter* iov_itr)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 static ssize_t bt_usb_readv(struct kiocb *kiocbp, const struct iovec *io,
                             unsigned long count, loff_t f_pos)
 #else
@@ -171,8 +170,11 @@
     ssize_t len;
     ssize_t no;
     read_q_elm_t *ptr;
+    int ret;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    inst = (bt_usb_instance_t *)kiocbp->ki_filp->private_data;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
     inst = (bt_usb_instance_t *)kiocbp->ki_filp->private_data;
 #else
     inst = (bt_usb_instance_t *)filp->private_data;
@@ -182,10 +184,15 @@
         return -ENODEV;
     }
 
-    
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)    
+    for (i = 0, len = 0; i < iov_itr->nr_segs; i++)
+#else
     for (i = 0, len = 0; i < count; i++)
+#endif
     {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+        if (!access_ok(VERIFY_WRITE, iov_itr->iov[i].iov_base, iov_itr->iov[i].iov_len))
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
         if (!access_ok(VERIFY_WRITE, io[i].iov_base, io[i].iov_len))
 #else
         if (verify_area(VERIFY_WRITE, io[i].iov_base, io[i].iov_len))
@@ -193,8 +200,11 @@
         {
             return -EFAULT;
         }
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+        len += iov_itr->iov[i].iov_len;
+#else
         len += io[i].iov_len;
+#endif
     }
 
     /* Grab lock and wait for data in queue */
@@ -223,14 +233,28 @@
         }
     }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    switch (iov_itr->nr_segs)
+#else
     switch (count)
+#endif
     {
         case 1: /* Getting size of next message */
             ptr = inst->first;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+            no = min(iov_itr->iov[0].iov_len,(size_t) sizeof(ptr->msg->buflen));
 
-            no = min(io[0].iov_len, sizeof(ptr->msg->buflen));
+           ret =  copy_to_user(iov_itr->iov[0].iov_base, &ptr->msg->buflen, no);
+#else
+            no = min(io[0].iov_len,(size_t) sizeof(ptr->msg->buflen));
 
-            copy_to_user(io[0].iov_base, &ptr->msg->buflen, no);
+           ret =  copy_to_user(io[0].iov_base, &ptr->msg->buflen, no);
+#endif
+
+           if(ret != 0)
+           {
+               printk(KERN_ERR "BT_USB: copy_to_user Failed !!!\n");
+           }
         break;
 
         case 2: /* Getting actual message (pop off queue) */
@@ -244,12 +268,22 @@
             }
             inst->count--;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+            no = copy_to_user(iov_itr->iov[0].iov_base, &ptr->channel,
+                min(iov_itr->iov[0].iov_len, (size_t)sizeof(ptr->channel)));
+#else
             no = copy_to_user(io[0].iov_base, &ptr->channel,
-                min(io[0].iov_len, sizeof(ptr->channel)));
+                min(io[0].iov_len, (size_t)sizeof(ptr->channel)));
+#endif
             if (no == 0)
             {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+                no = copy_to_user(iov_itr->iov[1].iov_base, ptr->msg->buf,
+                    min(iov_itr->iov[1].iov_len, (size_t)(ptr->msg->buflen)));
+#else
                 no = copy_to_user(io[1].iov_base, ptr->msg->buf,
-                    min(io[1].iov_len, ptr->msg->buflen));
+                    min(io[1].iov_len, (size_t)(ptr->msg->buflen)));
+#endif
             }
             if (no == 0)
             {
@@ -257,9 +291,13 @@
                 printk("Channel=%d\n", ptr->channel);
                 //dumpData((uint8_t*)ptr->msg->buf, ptr->msg->buflen);
 #endif
-
-                no = min(io[0].iov_len, sizeof(ptr->channel)) +
-                    min(io[1].iov_len, ptr->msg->buflen);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+                no = min(iov_itr->iov[0].iov_len, (size_t)sizeof(ptr->channel)) +
+                    min(iov_itr->iov[1].iov_len, (size_t)(ptr->msg->buflen));
+#else
+                no = min(io[0].iov_len, (size_t)sizeof(ptr->channel)) +
+                    min(io[1].iov_len, (size_t)(ptr->msg->buflen));
+#endif
             }
 
             pfree(ptr->msg->buf);
@@ -280,12 +318,18 @@
     return (no);
 }
 
+static ssize_t bt_usb_read_iter(struct kiocb *kiocbp, struct iov_iter *iter)
+{
+    printk("<1>BT_USB: bt_usb_read_iter\n");
+    return -EIO;
+}
+
 static ssize_t bt_usb_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
 {
     bt_usb_instance_t *inst;
+	unsigned char channel;
     ssize_t n = -1;
     int ret = -1;
-    unsigned char val = 0;
     read_q_elm_t *ptr = NULL;
 
     inst = (bt_usb_instance_t *)file->private_data;
@@ -301,6 +345,7 @@
     /* Grab lock and wait for data in queue */
     if (down_interruptible(&inst->access_sem))
     {
+		printk("%s : error, can not down_interruptible access_sem\n",__func__);
         return(-ERESTARTSYS);
     }
 
@@ -314,18 +359,19 @@
         if (wait_event_interruptible(inst->read_q,
                                      (inst->first != NULL)))
         {
+			printk("%s : error, wait_event_interruptible read_q\n",__func__);
             return(-ERESTARTSYS);
         }
 
         if (down_interruptible(&inst->access_sem))
         {
+			printk("%s : error, down_interruptible access_sem\n",__func__);
             return(-ERESTARTSYS);
         }
     }
 
     if (size > 1)
     {
-        unsigned char channel;
         ptr = inst->first;
 
         inst->first = ptr->next;
@@ -359,9 +405,9 @@
         if (ret == 0)
         {
             ret = copy_to_user(buf + 1, ptr->msg->buf,
-                min(size -1, ptr->msg->buflen));
+                min(size -1, (size_t)(ptr->msg->buflen)));
         }
-        n = ret == 0 ? min(size - 1, ptr->msg->buflen) + 1 : -1;
+        n = ret == 0 ? min(size - 1, (size_t)(ptr->msg->buflen)) + 1 : -1;
 
         pfree(ptr->msg->buf);
         pfree(ptr->msg);
@@ -377,7 +423,9 @@
     return n;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+static ssize_t bt_usb_writev(struct kiocb *kiocbp, struct iov_iter* iov_itr)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 static ssize_t bt_usb_writev(struct kiocb *kiocbp, const struct iovec *io,
                              unsigned long count,loff_t f_pos)
 #else
@@ -395,10 +443,16 @@
     
 
 #ifdef BT_USB_DEBUG
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    printk(KERN_ALERT "BT_USB: writev, count = %ld\n",iov_itr->nr_segs);
+#else
     printk(KERN_ALERT "BT_USB: writev, count = %ld\n",count);
 #endif
+#endif
     down(&inst_sem);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    inst = (bt_usb_instance_t *)kiocbp->ki_filp->private_data;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
     inst = (bt_usb_instance_t *)kiocbp->ki_filp->private_data;
 #else
     inst = (bt_usb_instance_t *)filp->private_data;
@@ -416,9 +470,17 @@
     }    
     up(&inst_sem);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    for (i = 0, len = 0; i < iov_itr->nr_segs; i++)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    for (i = 0, len = 0; i < count; i++)
+#else
     for (i = 0, len = 0; i < count; i++)
+#endif
     {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+        if (!access_ok(VERIFY_READ, iov_itr->iov[i].iov_base, iov_itr->iov[i].iov_len))
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
         if (!access_ok(VERIFY_READ, io[i].iov_base, io[i].iov_len))
 #else
         if (verify_area(VERIFY_READ, io[i].iov_base, io[i].iov_len))
@@ -426,22 +488,38 @@
         {
             return -EFAULT;
         }
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+        len+=iov_itr->iov[i].iov_len;
+#else
         len+=io[i].iov_len;
+#endif
     }
 
     /* Things can go wrong when getting data from userspace */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    i = copy_from_user(&channel,iov_itr->iov[0].iov_base,iov_itr->iov[0].iov_len);
+#else
     i = copy_from_user(&channel,io[0].iov_base,io[0].iov_len);
+#endif
     if(i == 0)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+        length = iov_itr->iov[1].iov_len;
+        buf = (unsigned char*) pmalloc(iov_itr->iov[1].iov_len);
+#else
         length = io[1].iov_len;
-        buf = pmalloc(io[1].iov_len);
+        buf = (unsigned char*) pmalloc(io[1].iov_len);
+#endif
         if (buf == NULL)
         {
           return -ENOMEM;
         }
 	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+        i = copy_from_user(buf,iov_itr->iov[1].iov_base,iov_itr->iov[1].iov_len);
+#else
         i = copy_from_user(buf,io[1].iov_base,io[1].iov_len);
+#endif
 
         if(i == 0)
         {
@@ -457,6 +535,12 @@
     return i;
 }
 
+static ssize_t bt_usb_write_iter(struct kiocb *kiocbp, struct iov_iter *iter)
+{
+    printk("<1>BT_USB: bt_usb_write_iter\n");
+    return -EIO;
+}
+
 static ssize_t bt_usb_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)
 {
     unsigned char channel = 0;
@@ -467,7 +551,7 @@
     int ret = -1;
 
 #ifdef BT_USB_DEBUG
-    printk("BT_USB: write, count = %ld\n",count);
+    printk("BT_USB: write, count = %d\n",count);
 #endif
     down(&inst_sem);
 
@@ -507,7 +591,7 @@
             }
 
             payload_size = count - 1;
-            payload = pmalloc(payload_size);
+            payload = (unsigned char *)pmalloc(payload_size);
             if (payload == NULL)
             {
                 return -ENOMEM;
@@ -553,13 +637,13 @@
     /* Is device minor within range? */
     if (minor >= BT_USB_COUNT)
     {
-        printk("bt_usb: count exceeded");
+        printk("bt_usb: count exceeded\n");
         return -ENXIO;
     }
     
     if(!devExist(minor))
     {
-        printk("bt_usb: no device probed yet");
+        printk("bt_usb: no device probed yet\n");
         return -ENXIO;
     }
     
@@ -574,7 +658,7 @@
 #endif
    if(&instances[minor] == NULL)
    	{
-   	up(&inst_sem);
+		up(&inst_sem);
         printk("bt_usb%u: is null",minor);
         return -EBUSY;
    	}
@@ -582,7 +666,7 @@
     up(&inst_sem);
     if (inst == NULL)
     {
-      printk("bt_usb%u: no instance yet");
+      printk("bt_usb: no instance yet");
     	return -ENOMEM;
     }
     inst->minor = minor;
@@ -635,7 +719,7 @@
 
         ptr = next;
     }
-    printk("wake up interrupt on release %p %p\n",&inst, &(inst->read_q));
+    printk("%s:wake up interrupt on release %p %p\n",__func__,&inst, &(inst->read_q));
     inst->first = NULL;
     inst->last = NULL;
     inst->count = 0;   
@@ -684,6 +768,7 @@
     return (inst->first?(POLLIN | POLLRDNORM):0);
 }
                         
+#if 0
 static int bt_usb_ioctl(struct inode *inode, struct file *filp,
                         unsigned int cmd, unsigned long arg)
 
@@ -747,16 +832,25 @@
     return ret;
 }
 
+#endif
 static struct file_operations bt_usb_fops =
 {
     owner     : THIS_MODULE,
     //ioctl     : bt_usb_ioctl,
     open      : bt_usb_open,
     release   : bt_usb_release,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+    read_iter  : bt_usb_readv,
+    write_iter : bt_usb_writev,
+    poll      : bt_usb_poll,
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
     aio_read  : bt_usb_readv,
     aio_write : bt_usb_writev,
     poll      : bt_usb_poll,
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,1))
+    read_iter : bt_usb_read_iter,
+    write_iter: bt_usb_write_iter,
+    poll      : bt_usb_poll,
 #else
     writev    : bt_usb_writev,
     readv     : bt_usb_readv,
@@ -980,6 +1074,7 @@
 
     up(&inst_sem);
 #endif
+    printk("BT_USB: bt_usb_init done!\n");
 
     return (0);
 }
diff -Nur bt_usb_driver/include/linux_usb_com.h bt_usb_driver-new/include/linux_usb_com.h
--- bt_usb_driver/include/linux_usb_com.h	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/include/linux_usb_com.h	2019-04-09 16:59:08.073044097 +0800
@@ -38,14 +38,20 @@
 extern "C" {
 #endif
 
+#define CONFIG_USB_SUSPEND
+
 /* Misc */
 #define BT_CTRL_REQUEST         0x20
-#define PRNPREFIX               "<1>csr_usb: "
+#define PRNPREFIX               "<1>qcom_usb: "
 
 /* CSR nanosira information */
 #define CSR_VENDOR_ID           0x0A12
 #define CSR_PRODUCT_ID          0x0001
 
+/* QCOM rome information */
+#define QCOM_VENDOR_ID           0x0CF3
+#define QCOM_PRODUCT_ID          0xe007
+
 /* Packet sizes */
 #define HCI_EVENT_HDR_SIZE      2 /* event=1, length=1 */
 #define HCI_COMMAND_HDR_SIZE    3 /* opcode=2, length=1 */
@@ -84,7 +90,7 @@
 
 /* Number of USB devices to support in pure user mode */
 #ifndef BT_USB_COUNT
-#define BT_USB_COUNT                                        (3)
+#define BT_USB_COUNT                                        (1)
 #endif /* BT_USB_COUNT */
 
 /* Queueing of BULK and ISOC URBs is legal, hence we allow multiple
@@ -176,7 +182,8 @@
     uint8_t                      intr_ep;
     uint8_t                      intr_interval;
     uint16_t                     intr_size;
-    struct urb                *intr_urb;
+    struct urb                   *intr_urb;
+	void                         *intr_buf;
     uint8_t                      *intr_reassembly;
     uint16_t                     intr_remain;
     uint16_t                     intr_total;
@@ -184,6 +191,7 @@
     /* BULK-in endpoint (acl) */
     uint8_t                      bulk_in_ep;
     struct urb                   *bulk_urb[MAX_RX_BULK_URBS];
+    void 						 *bulk_buf[MAX_RX_BULK_URBS];
 
     /* BULK-out endpoint (acl) */
     uint8_t                      bulk_out_ep;
diff -Nur bt_usb_driver/include/linux_usb_extra.h bt_usb_driver-new/include/linux_usb_extra.h
--- bt_usb_driver/include/linux_usb_extra.h	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/include/linux_usb_extra.h	2019-04-09 16:54:53.473035250 +0800
@@ -161,6 +161,7 @@
 void SetUsbMaxIsocInFrames(int in);
 void SetUsbMaxIsocOutFrames(int out);
 bool devExist(uint8_t devno);
+csr_dev_t *devLookup(uint8_t devno);
 /* Structure to hold the static settings (before the driver is initialized) */
 typedef struct
 {
diff -Nur bt_usb_driver/include/usb_com.h bt_usb_driver-new/include/usb_com.h
--- bt_usb_driver/include/usb_com.h	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/include/usb_com.h	2019-04-09 16:55:00.853035506 +0800
@@ -69,6 +69,7 @@
  *----------------------------------------------------------------------------*/
 void hcCom_ReceiveMsg(void *msg, uint8_t bcspChannel, uint8_t rel);
 
+void    bt_usb_cleanup(csr_dev_t *dv);
 bool  UsbDrv_Start(char *deviceName);
 void    UsbDrv_Stop(void);
 
diff -Nur bt_usb_driver/Makefile bt_usb_driver-new/Makefile
--- bt_usb_driver/Makefile	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/Makefile	2019-04-09 17:02:44.785051628 +0800
@@ -1,29 +1,42 @@
+#ARCH = arm
+#CROSS_COMPILE = /home/tjiang/CE/NRT/Hisense/arm-2014.05/bin/arm-none-linux-gnueabi-
+#KERNEL_SRC := /lib/modules/$(shell uname -r)/build
+KERNEL_SRC := /lib/modules/4.9.11+/build
 
-#KBUILD_CFLAGS += -D__linux__
-EXTRA_CFLAGS=-fno-pic
-
-obj-m += bt_usb.o
-
-bt_usb-objs += \
-	bt_usb_main.o \
-	usb_com.o \
-	usb_intf.o \
-	usb_queue.o \
-	usb_dfu.o
+USB_MOD_NAME = bt_usb_qcom
 
-KDIR ?= /home/victor/android/kernel/friendly_arm/linux-3.0.86
-KVER ?= 3.0.86
+EXTRA_CFLAGS=-fno-pic
 
-PWD := $(shell pwd)
-CURFOLDER ?= $(pwd)
+USB_CFILES := \
+	bt_usb_main.c \
+	usb_com.c \
+	usb_intf.c \
+	usb_queue.c \
+	usb_dfu.c \
+	rome.c
+
+$(USB_MOD_NAME)-objs := $(USB_CFILES:.c=.o)
 
-EXTRA_CFLAGS += -I$(CURFOLDER)/include -D__linux__
+obj-m := $(USB_MOD_NAME).o
 
-bt_usb:
-	$(MAKE) -C $(KDIR) M=$(PWD) modules
+all:
+	make -C $(KERNEL_SRC) M=$(PWD) modules
 
+usb:
+	make -C $(KERNEL_SRC) M=$(PWD) $(USB_MOD_NAME).ko
 
 clean:
-	$(MAKE) -C $(KDIR) M=$(PWD) clean
-	$(RM) Module.markers
-	$(RM) modules.order
+	make -C $(KERNEL_SRC) M=$(PWD) clean
+
+#EXTRA_CFLAGS=-fno-pic
+#
+#obj-m += bt_usb_qcom.o
+#
+#bt_usb_qcom-objs += \
+#	bt_usb_main.o \
+#	usb_com.o \
+#	usb_intf.o \
+#	usb_queue.o \
+#	usb_dfu.o \
+#	rome.o
+#
diff -Nur bt_usb_driver/rome.c bt_usb_driver-new/rome.c
--- bt_usb_driver/rome.c	1970-01-01 08:00:00.000000000 +0800
+++ bt_usb_driver-new/rome.c	2019-03-15 15:39:34.569999000 +0800
@@ -0,0 +1,586 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted (subject to the limitations in the
+ * disclaimer below) provided that the following conditions are met:
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY
+ * THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/string.h>  /* for memcpy() */
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/usb.h>
+#include <linux/usb.h>
+#include <linux/fs.h>
+#include <asm/segment.h>
+#include <asm/uaccess.h>
+
+struct ath3k_version {
+    unsigned int	rom_version;
+    unsigned int	build_version;
+    unsigned int	ram_version;
+    unsigned char	ref_clock;
+    unsigned char	reserved[0x07];
+};
+struct __packed rome1_1_version {
+    u8  type;
+    u8  length[3];
+    u8  sign_ver;
+    u8  sign_algo;
+    u8  resv1[2];
+    u16 product_id;
+    u16 build_ver;
+    u16 patch_ver;
+    u8  resv2[2];
+    u32 entry_addr;
+};
+struct __packed rome2_1_version {
+    u8  type;
+    u8  length[3];
+    u32 total_len;
+    u32 patch_len;
+    u8  sign_ver;
+    u8  sign_algo;
+    u8  resv1[2];
+    u16 product_id;
+    u16 build_ver;
+    u16 patch_ver;
+    u8  resv2[2];
+    u32 entry_addr;
+};
+
+#define BTUSB_TEST(fmt, ...) \
+    printk(KERN_ERR "Bluetooth: [BTUSB]: " fmt, ##__VA_ARGS__)
+#define BT_INFO(fmt, arg...)    printk(KERN_ERR "Bluetooth: " fmt "\n" , ## arg)
+#define BT_ERR(fmt, arg...)     printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
+#define BT_DBG                  BTUSB_TEST
+
+#define ROME1_1_USB_CHIP_VERSION        0x101
+#define ROME2_1_USB_CHIP_VERSION        0x200
+#define ROME3_0_USB_CHIP_VERSION        0x300
+#define ROME3_2_USB_CHIP_VERSION        0x302
+#define NPL1_0_USB_CHIP_VERSION         0xc0100
+
+#define ROME1_1_USB_RAMPATCH_FILE   "ar3k/rampatch_1.1.img"
+#define ROME1_1_USB_NVM_FILE        "ar3k/nvm_tlv_usb_1.1.bin"
+
+#define ROME2_1_USB_RAMPATCH_FILE   "ar3k/rampatch_tlv_usb_2.1.tlv"
+#define ROME2_1_USB_NVM_FILE        "ar3k/nvm_tlv_usb_2.1.bin"
+
+#define ROME3_0_USB_RAMPATCH_FILE   "ar3k/rampatch_tlv_usb_3.0.tlv"
+#define ROME3_0_USB_NVM_FILE        "ar3k/nvm_tlv_usb_3.0.bin"
+
+#define ROME3_2_USB_RAMPATCH_FILE   "ar3k/rampatch_tlv_usb_3.2.tlv"
+#define ROME3_2_USB_NVM_FILE        "ar3k/nvm_tlv_usb_3.2.bin"
+
+#define TF1_1_USB_RAMPATCH_FILE     "ar3k/rampatch_tlv_usb_tf_1.1.tlv"
+#define TF1_1_USB_NVM_FILE          "ar3k/nvm_tlv_usb_tf_1.1.bin"
+
+#define NPL1_0_USB_RAMPATCH_FILE    "rampatch_tlv_usb_npl_1.0.tlv"
+#define NPL1_0_USB_NVM_FILE         "nvm_tlv_usb_npl_1.0.bin"
+
+#define ROME2_1_USB_RAMPATCH_HEADER sizeof(struct rome2_1_version)
+#define ROME1_1_USB_RAMPATCH_HEADER sizeof(struct rome1_1_version)
+
+#define ROME1_1_USB_NVM_HEADER      0x04
+#define ROME2_1_USB_NVM_HEADER      0x04
+
+#define TF1_1_USB_PRODUCT_ID        0xe500
+#define ATH3K_DNLOAD                0x01
+#define ATH3K_GETSTATE              0x05
+#define ATH3K_GETVERSION            0x09
+
+/* 0xA2 : RAMPATCH ALONE DOWNLOADED FROM FLASH */
+#define ATH3K_PATCH_UPDATE			0xA2
+
+/* 0x61 : NVM ALONE DOWNLOADED FROM FLASH */
+#define ATH3K_SYSCFG_UPDATE			0x61
+
+/* 0xE3 : RAMPATCH & NVM BOTH DOWNLOADED FROM FLASH */
+#define ATH3K_PATCH_SYSCFG_UPDATE		(ATH3K_PATCH_UPDATE | ATH3K_SYSCFG_UPDATE)
+
+/* 0x20 : NO FW DOWNLOADED */
+
+#define ATH3K_XTAL_FREQ_26M     0x00
+#define ATH3K_XTAL_FREQ_40M     0x01
+#define ATH3K_XTAL_FREQ_19P2    0x02
+#define ATH3K_NAME_LEN          0xFF
+#define ATH3K_PATH_LEN          ( ATH3K_NAME_LEN + 15 /* for absolute path + extra null character */)
+
+
+#define BULK_SIZE               4096
+#define FW_HDR_SIZE             20
+
+#define PATCH_UPDATE_MASK       0x80
+#define SYSCFG_UPDATE_MASK      0x40
+
+
+extern int request_firmware(const struct firmware **firmware_p, const char *name, struct device *device);
+extern void release_firmware(const struct firmware *fw);
+
+static bool file_exists(const char *fname)
+{
+    bool exists = true;
+    mm_segment_t old_fs;
+    struct file* fp   = NULL;
+
+    old_fs = get_fs();
+    set_fs(get_ds());
+    fp = filp_open(fname, O_RDONLY, 0);
+    set_fs(old_fs);
+
+    if(IS_ERR(fp))
+    {
+        exists = false;
+        BT_ERR(" File [%s]  Error (%ld)\n", fname, PTR_ERR(fp));
+    }
+    else
+    {
+        filp_close(fp, NULL);
+        BT_INFO(" File [%s]  exists \n", fname);
+    }
+
+    return exists;
+}
+
+static int ath3k_get_version(struct usb_device *udev,
+            struct ath3k_version *version)
+{
+    int ret, pipe = 0;
+    struct ath3k_version *buf;
+    const int size = sizeof(*buf);
+
+    buf = kmalloc(size, GFP_KERNEL);
+    if (!buf)
+        return -ENOMEM;
+
+    pipe = usb_rcvctrlpipe(udev, 0);
+    ret = usb_control_msg(udev, pipe, ATH3K_GETVERSION,
+              USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,
+              buf, size, USB_CTRL_SET_TIMEOUT);
+
+    memcpy(version, buf, size);
+    kfree(buf);
+
+    return ret;
+}
+
+
+int get_rome_version(struct usb_device *udev, struct ath3k_version *version)
+{
+    struct ath3k_version fw_version;
+    int ret = -1;
+
+    if (!version) {
+        BT_ERR("NULL output parameters");
+        return ret;
+    }
+
+    ret = ath3k_get_version(udev, &fw_version);
+    if (ret < 0) {
+        BT_ERR("Failed to get Rome Firmware version");
+        return ret;
+    }
+
+    memcpy(version, &fw_version, sizeof(struct ath3k_version));
+    return 0;
+}
+
+static int ath3k_get_state(struct usb_device *udev, unsigned char *state)
+{
+    int ret, pipe = 0;
+    char *buf;
+
+    buf = kmalloc(sizeof(*buf), GFP_KERNEL);
+    if (!buf)
+        return -ENOMEM;
+
+    pipe = usb_rcvctrlpipe(udev, 0);
+    ret = usb_control_msg(udev, pipe, ATH3K_GETSTATE,
+                  USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,
+                  buf, sizeof(*buf), USB_CTRL_SET_TIMEOUT);
+
+    *state = *buf;
+    kfree(buf);
+
+    return ret;
+}
+
+static int ath3k_load_fwfile(struct usb_device *udev,
+        const struct firmware *firmware, int header_h)
+{
+    u8 *send_buf;
+    int err, pipe, len, size, count, sent = 0;
+    int ret;
+
+    count = firmware->size;
+
+    send_buf = kmalloc(BULK_SIZE, GFP_KERNEL);
+    if (!send_buf) {
+        BT_ERR("Can't allocate memory chunk for firmware");
+        return -ENOMEM;
+    }
+
+    size = min_t(uint, count, header_h);
+    memcpy(send_buf, firmware->data, size);
+
+    pipe = usb_sndctrlpipe(udev, 0);
+    ret = usb_control_msg(udev, pipe, ATH3K_DNLOAD,
+            USB_TYPE_VENDOR, 0, 0, send_buf,
+            size, USB_CTRL_SET_TIMEOUT);
+    if (ret < 0) {
+        BT_ERR("Can't change to loading configuration err");
+        kfree(send_buf);
+        return ret;
+    }
+
+    sent += size;
+    count -= size;
+
+    while (count) {
+        size = min_t(uint, count, BULK_SIZE);
+        pipe = usb_sndbulkpipe(udev, 0x02);
+
+        memcpy(send_buf, firmware->data + sent, size);
+
+        err = usb_bulk_msg(udev, pipe, send_buf, size,
+                    &len, 3000);
+        if (err || (len != size)) {
+            BT_ERR("Error in firmware loading err = %d,"
+                "len = %d, size = %d", err, len, size);
+            kfree(send_buf);
+            return err;
+        }
+        sent  += size;
+        count -= size;
+    }
+
+    kfree(send_buf);
+    return 0;
+}
+
+
+
+static int ath3k_load_patch(struct usb_device *udev,
+                        struct ath3k_version *version)
+{
+    unsigned char fw_state;
+    char filename[ATH3K_NAME_LEN] = {0};
+    const struct firmware *firmware;
+    struct ath3k_version pt_version;
+    struct rome2_1_version *rome2_1_version;
+    struct rome1_1_version *rome1_1_version;
+    int ret;
+    char file_path[ATH3K_PATH_LEN] = {0};
+
+    BT_INFO("%s: Get FW STATE prior to downloading the RAMAPCTH\n", __func__);
+    printk(KERN_ERR "%s: Get FW STATE prior to downloading the RAMAPCTH\n", __func__);
+    ret = ath3k_get_state(udev, &fw_state);
+    if (ret < 0) {
+        BT_ERR("Can't get state to change to load ram patch err");
+        printk(KERN_ERR "%s: Can't get state to change to load ram patch err\n", __func__);
+        return ret;
+    }
+
+    if (fw_state & PATCH_UPDATE_MASK) {
+            BT_INFO("%s: Patch already downloaded(fw_state: 0x%x)", __func__,
+            fw_state);
+            printk(KERN_ERR "%s: Patch already downloaded(fw_state: 0x%x)\n", __func__, fw_state);
+            return 0;
+    }
+    else
+    {
+        BT_INFO("%s: Downloading RamPatch(fw_state: 0x%x)\n", __func__,
+            fw_state);
+        printk(KERN_ERR "%s: Downloading RamPatch(fw_state: 0x%x)\n", __func__, fw_state);
+    }
+
+    switch (version->rom_version) {
+
+    case ROME1_1_USB_CHIP_VERSION:
+        BT_DBG("Chip Detected as ROME1.1");
+        snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_RAMPATCH_FILE);
+        break;
+
+    case ROME2_1_USB_CHIP_VERSION:
+        BT_DBG("Chip Detected as ROME2.1");
+        snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_RAMPATCH_FILE);
+        break;
+
+    case ROME3_0_USB_CHIP_VERSION:
+        BT_DBG("Chip Detected as ROME3.0");
+        printk(KERN_ERR "%s: Chip Detected as ROME3.0\n", __func__);
+        snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_RAMPATCH_FILE);
+        break;
+
+    case ROME3_2_USB_CHIP_VERSION:
+        if (udev->descriptor.idProduct == TF1_1_USB_PRODUCT_ID) {
+            BT_DBG("Chip Detected as TF1.1");
+            snprintf(filename, ATH3K_NAME_LEN,
+                TF1_1_USB_RAMPATCH_FILE);
+        }
+        else
+        {
+            BT_INFO("ath3k_load_patch: ROME 3.2 Chip");
+        	snprintf(filename, ATH3K_NAME_LEN, ROME3_2_USB_RAMPATCH_FILE);
+        }
+        break;
+
+    case NPL1_0_USB_CHIP_VERSION:
+        BT_DBG("Chip Detected as Naples1.0");
+        snprintf(filename, ATH3K_NAME_LEN, NPL1_0_USB_RAMPATCH_FILE);
+        break;
+
+    default:
+        BT_DBG("Chip Detected as Ath3k");
+        snprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",
+        version->rom_version);
+        break;
+    }
+
+    snprintf(file_path,ATH3K_PATH_LEN,"/lib/firmware/%s", filename);
+
+    if ( false == file_exists(file_path) )
+    {
+        ret = -EEXIST;
+        BT_ERR("File(%s) Error \n", file_path);
+        return ret;
+    }
+
+    ret = request_firmware(&firmware, filename, &udev->dev);
+
+    if (ret < 0) {
+        BT_ERR("Patch file not found %s", filename);
+        printk(KERN_ERR "%s: Patch file not found %s\n", __func__, filename);
+        return ret;
+    }
+    else
+    {
+        printk(KERN_ERR "%s: Find Patch file %s\n", __func__, filename);
+    }
+
+    if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
+        (version->rom_version == ROME3_0_USB_CHIP_VERSION) ||
+        (version->rom_version == ROME3_2_USB_CHIP_VERSION) ||
+        (version->rom_version == NPL1_0_USB_CHIP_VERSION)) {
+        rome2_1_version = (struct rome2_1_version *) firmware->data;
+        pt_version.rom_version = rome2_1_version->build_ver;
+        pt_version.build_version = rome2_1_version->patch_ver;
+        BT_DBG("pt_ver.rome_ver : 0x%x\n", pt_version.rom_version);
+        BT_DBG("pt_ver.build_ver: 0x%x\n", pt_version.build_version);
+        BT_DBG("fw_ver.rom_ver: 0x%x\n", version->rom_version);
+        BT_DBG("fw_ver.build_ver: 0x%x\n", version->build_version);
+    } else if (version->rom_version == ROME1_1_USB_CHIP_VERSION) {
+        rome1_1_version = (struct rome1_1_version *) firmware->data;
+        pt_version.build_version = rome1_1_version->build_ver;
+        pt_version.rom_version = rome1_1_version->patch_ver;
+        BT_DBG("pt_ver.rom1.1_ver : 0x%x", pt_version.rom_version);
+        BT_DBG("pt_ver.build1.1_ver: 0x%x", pt_version.build_version);
+        BT_DBG("fw_ver.rom1.1_ver: 0x%x", version->rom_version);
+        BT_DBG("fw_ver.build1.1_ver: 0x%x", version->build_version);
+    } else {
+    pt_version.rom_version = *(int *)(firmware->data + firmware->size - 8);
+    pt_version.build_version = *(int *)(firmware->data + firmware->size - 4);
+    }
+
+    if ((pt_version.rom_version != (version->rom_version & 0xffff)) ||
+        (pt_version.build_version <= version->build_version)) {
+        BT_ERR("Patch file version did not match with firmware\n");
+        release_firmware(firmware);
+        return -EINVAL;
+    }
+
+    if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
+        (version->rom_version == ROME3_0_USB_CHIP_VERSION) ||
+        (version->rom_version == ROME3_2_USB_CHIP_VERSION) ||
+        (version->rom_version == NPL1_0_USB_CHIP_VERSION)) {
+        BT_ERR("%s: Loading RAMPATCH...", __func__);
+        ret = ath3k_load_fwfile(udev, firmware,
+                        ROME2_1_USB_RAMPATCH_HEADER);
+        }
+    else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
+        ret = ath3k_load_fwfile(udev, firmware, ROME1_1_USB_RAMPATCH_HEADER);
+    else
+        ret = ath3k_load_fwfile(udev, firmware, FW_HDR_SIZE);
+
+    release_firmware(firmware);
+
+    BT_DBG("%s: DONE Downloading RamPatch", __func__);
+
+    return ret;
+}
+
+static int ath3k_load_syscfg(struct usb_device *udev,
+                        struct ath3k_version *version)
+{
+    unsigned char fw_state;
+    char filename[ATH3K_NAME_LEN] = {0};
+    const struct firmware *firmware;
+    int clk_value, ret;
+    char file_path[ATH3K_PATH_LEN] = {0};
+
+    BT_INFO("%s: Get FW STATE prior to downloading the NVM\n", __func__);
+    ret = ath3k_get_state(udev, &fw_state);
+    if (ret < 0) {
+        BT_ERR("Can't get state to change to load configuration err");
+        return -EBUSY;
+    }
+
+    if (fw_state & SYSCFG_UPDATE_MASK) {
+        BT_INFO("%s: NVM already downloaded(fw_state: 0x%x)\n", __func__,
+            fw_state);
+        return 0;
+    } else
+        BT_INFO("%s: Downloading NVM(fw_state: 0x%x)\n", __func__, fw_state);
+
+    switch (version->ref_clock) {
+    case ATH3K_XTAL_FREQ_26M:
+        clk_value = 26;
+        break;
+    case ATH3K_XTAL_FREQ_40M:
+        clk_value = 40;
+        break;
+    case ATH3K_XTAL_FREQ_19P2:
+        clk_value = 19;
+        break;
+    default:
+        clk_value = 0;
+        break;
+    }
+
+    if (version->rom_version == ROME2_1_USB_CHIP_VERSION)
+        snprintf(filename, ATH3K_NAME_LEN, ROME2_1_USB_NVM_FILE);
+    else if (version->rom_version == ROME3_0_USB_CHIP_VERSION)
+        snprintf(filename, ATH3K_NAME_LEN, ROME3_0_USB_NVM_FILE);
+    else if (version->rom_version == ROME3_2_USB_CHIP_VERSION)
+    {
+        if (udev->descriptor.idProduct == TF1_1_USB_PRODUCT_ID)
+            snprintf(filename, ATH3K_NAME_LEN, TF1_1_USB_NVM_FILE);
+        else
+        {
+            BT_INFO("ath3k_load_syscfg: ROME 3.2 Chip\n");
+        	snprintf(filename, ATH3K_NAME_LEN, ROME3_2_USB_NVM_FILE);
+        }
+    }
+    else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
+        snprintf(filename, ATH3K_NAME_LEN, ROME1_1_USB_NVM_FILE);
+    else if (version->rom_version == NPL1_0_USB_CHIP_VERSION)
+        snprintf(filename, ATH3K_NAME_LEN, NPL1_0_USB_NVM_FILE);
+    else
+        snprintf(filename, ATH3K_NAME_LEN, "ar3k/ramps_0x%08x_%d%s",
+            version->rom_version, clk_value, ".dfu");
+
+    snprintf(file_path,ATH3K_PATH_LEN,"/lib/firmware/%s", filename);
+
+    if ( false == file_exists(file_path) )
+    {
+        ret = -EEXIST;
+        BT_ERR("File(%s) Error \n", file_path);
+        return ret;
+    }
+
+    ret = request_firmware(&firmware, filename, &udev->dev);
+    if (ret < 0) {
+        BT_ERR("Configuration file not found %s", filename);
+        return ret;
+    }
+    else
+    {
+        printk(KERN_ERR "%s: Configuration file found %s\n", __func__, filename);
+    }
+
+    if ((version->rom_version == ROME2_1_USB_CHIP_VERSION) ||
+        (version->rom_version == ROME3_0_USB_CHIP_VERSION) ||
+        (version->rom_version == ROME3_2_USB_CHIP_VERSION) ||
+        (version->rom_version == NPL1_0_USB_CHIP_VERSION)) {
+        BT_ERR("%s: Loading NVM...", __func__);
+        ret = ath3k_load_fwfile(udev, firmware, ROME2_1_USB_NVM_HEADER);
+        }
+    else if (version->rom_version == ROME1_1_USB_CHIP_VERSION)
+        ret = ath3k_load_fwfile(udev, firmware, ROME1_1_USB_NVM_HEADER);
+    else
+        ret = ath3k_load_fwfile(udev, firmware, FW_HDR_SIZE);
+
+    release_firmware(firmware);
+
+	ath3k_get_state(udev, &fw_state); 
+	BT_DBG("%s: DONE: Downloading NVM,fw_state 0x%x\n",
+			  __func__,fw_state);
+
+    return ret;
+}
+
+
+int rome_download(struct usb_device *udev, struct ath3k_version *version)
+{
+    int ret;
+
+    ret = ath3k_load_patch(udev, version);
+    if (ret < 0) {
+        BT_ERR("Loading patch file failed");
+        printk(KERN_ERR "%s: Loading patch file failed\n", __func__);
+        return ret;
+    }
+    else
+    {
+        printk(KERN_ERR "%s: Succeed Loading patch file\n", __func__);
+    }
+
+    ret = ath3k_load_syscfg(udev, version);
+
+    if (ret < 0) {
+        BT_ERR("Loading sysconfig file failed");
+        printk(KERN_ERR "%s: Loading sysconfig file failed\n", __func__);
+        return ret;
+    }
+    else
+    {
+        printk(KERN_ERR "%s: Succeed Loading sysconfig file\n", __func__);
+    }
+
+    return 0;
+}
+
+void btusb_firmware_upgrade(struct usb_device *udev)
+{
+
+    struct ath3k_version version;
+    int err;
+
+    printk(KERN_ERR "%s: Start Downloading Rampatch and NVM\n", __func__);
+    err = get_rome_version(udev, &version);
+    if (err < 0) {
+        BT_ERR("Failed to get ROME USB version");
+        printk(KERN_ERR "%s: Failed to get ROME USB version\n", __func__);
+    }
+    BT_INFO("Rome Version: 0x%x\n", version.rom_version);
+    err = rome_download(udev, &version);
+    if (err < 0) {
+        BT_ERR("Failed to download ROME firmware");
+        printk(KERN_ERR "%s: \n", __func__);
+        printk(KERN_ERR "%s: Failed to download ROME firmware\n", __func__);
+    }
+    else
+    {
+        printk(KERN_ERR "%s: Succeed Downloading Rampatch and NVM\n", __func__);
+    }
+}
diff -Nur bt_usb_driver/usb_com.c bt_usb_driver-new/usb_com.c
--- bt_usb_driver/usb_com.c	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/usb_com.c	2019-04-09 17:03:54.449054048 +0800
@@ -83,10 +83,26 @@
 {
     { USB_DEVICE(0x0DB0, 0xA871) },
     { USB_DEVICE(CSR_VENDOR_ID, CSR_PRODUCT_ID) },      //{ USB_DEVICE(0x0A12, 0x0001)   },
+    { USB_DEVICE(QCOM_VENDOR_ID, QCOM_PRODUCT_ID) },      //QCOM ROME
+    { USB_DEVICE(0x0cf3, 0xe300) },
+    { USB_DEVICE(0x0cf3, 0xe500) },
+    { USB_DEVICE(0x04b3, 0x3107) }, //Broadcom dongle
+    { USB_DEVICE(0x0a5c, 0x21ec) }, //Broadcom dongle
+    { USB_DEVICE(0x04ca, 0x3016) }, //Lite On dongle
     {  }, /* END */
 };
 MODULE_DEVICE_TABLE(usb, csr_device_table);
 
+#define BTUSB_ATH3012   0x80
+struct usb_device_id fw_update_device_table[] =
+{
+    { USB_DEVICE(QCOM_VENDOR_ID, QCOM_PRODUCT_ID),.driver_info = BTUSB_ATH3012 },      //QCOM ROME
+    { USB_DEVICE(0x0cf3, 0xe300),.driver_info = BTUSB_ATH3012 },
+    { USB_DEVICE(0x0cf3, 0xe500),.driver_info = BTUSB_ATH3012 },
+    { USB_DEVICE(0x04ca, 0x3016),.driver_info = BTUSB_ATH3012 },
+    {  }, /* END */
+};
+
 /* Global settings with default */
 csr_usb_settings_t csr_setup =
 {
@@ -115,21 +131,25 @@
     .probe                        = csrUsbProbe,
     .disconnect                   = csrUsbDisconnect,
 #ifdef CONFIG_USB_SUSPEND
-	.suspend					  = csrUsbSuspend,
-	.resume						  = csrUsbResume,
-	.reset_resume				  = csrUsbResetResume,
-	.supports_autosuspend		  = 1,
+    .suspend                      = csrUsbSuspend,
+    .resume                       = csrUsbResume,
+    .reset_resume                 = csrUsbResetResume,
+    .supports_autosuspend         = 1,
 #endif
 };
 
 /* Local prototypes */
 static int16_t usbRxIntr(csr_dev_t *dv);
 static int16_t usbRxBulk(csr_dev_t *dv, uint8_t number);
+
+#ifdef CSR_BR_USB_USE_SCO_INTF
 static int16_t usbRxIsoc(csr_dev_t *dv, uint8_t number);
+#endif
 
 extern void pfree(void *ptr);
 extern void *zpmalloc(size_t size);
 extern void *pmalloc(size_t size);
+extern void btusb_firmware_upgrade(struct usb_device *udev);
 /*************************************************************
  * NAME:
  *      csrSlotFromUsb
@@ -194,7 +214,8 @@
 
     if(dv->intr_urb != NULL)
     {
-        DBG_PRINT("Unlink and free Rx INTR\n");
+        printk("%s:Unlink and free Rx INTR\n",__func__);
+		pfree(dv->intr_buf);
         URB_UNLINK(dv->intr_urb);
         usb_free_urb(dv->intr_urb);
         dv->intr_urb = NULL;
@@ -203,7 +224,8 @@
     {
         if(dv->bulk_urb[i] != NULL)
         {
-            DBG_PRINT("Unlink and free Rx BULK_%i\n", i);
+            DBG_PRINT("%s:Unlink and free Rx BULK_%i\n", __func__,i);
+			pfree(dv->bulk_buf[i]);
             URB_UNLINK(dv->bulk_urb[i]);
             usb_free_urb(dv->bulk_urb[i]);
             dv->bulk_urb[i] = NULL;
@@ -265,7 +287,7 @@
 
     if (test_bit(R_THREAD_RUNNING, &(dv->flags)))
     {
-        DBG_PRINT("Stopping the reader thread\n");
+        printk("Stopping the reader thread\n");
 
         clear_bit(R_THREAD_RUNNING, &(dv->flags));
         wake_up_interruptible(&(dv->queue.wait));
@@ -278,11 +300,11 @@
 
         /* XXX: Is this whole dance correct? */
 
-        DBG_PRINT("The reader thread has been stopped\n");
+        printk("The reader thread has been stopped\n");
     }
     else
     {
-        DBG_PRINT("Reader thread was not running\n");
+        printk("Reader thread was not running\n");
     }
 
     /* Set the flags indicating that the module must be stopped */
@@ -291,8 +313,10 @@
     clear_bit(BULK_IN_READY, &(dv->endpoint_present));
     clear_bit(BULK_OUT_READY, &(dv->endpoint_present));
     clear_bit(INTR_IN_READY, &(dv->endpoint_present));
+#ifdef CSR_BR_USB_USE_SCO_INTF
     clear_bit(ISOC_IN_READY, &(dv->endpoint_present));
     clear_bit(ISOC_OUT_READY, &(dv->endpoint_present));
+#endif
     clear_bit(EXTRA_INTERFACE_READY, &(dv->endpoint_present));
 #ifdef CSR_BR_USB_USE_DFU_INTF    
     clear_bit(DFU_READY, &(dv->endpoint_present));
@@ -319,12 +343,14 @@
     QueueFree(dv);
     usbCleanUrbs(dv);
 
+    device_set_wakeup_capable(&(uDev->dev),false);
+    device_set_wakeup_enable(&(uDev->dev),0);
     /* Nothing should be using the device at
      * this point, so it's safe to free it.
      */
     pfree(dv);
 
-    DBG_PRINT("bt_usb%u: device removed\n", devno);
+    printk(KERN_ERR "bt_usb%u: device removed\n", devno);
 }
 
 /*************************************************************
@@ -415,6 +441,7 @@
  *      void
  *
  *************************************************************/
+#ifdef CSR_BR_USB_USE_SCO_INTF
 #if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)))
 static void usbTxIsocComplete(struct urb *urb, struct pt_regs *regs)
 #else
@@ -437,7 +464,7 @@
     /* Free the data no matter what */
     kfree(urb->transfer_buffer);
 }
-
+#endif
 
 /*************************************************************
  * NAME:
@@ -831,7 +858,7 @@
 static int32_t reassembleIntr(struct urb *urb)
 {
     csr_dev_t *dv;
-    uint32_t length;
+    uint16_t length;
     uint32_t len;
     uint8_t  *data;
 
@@ -1157,6 +1184,7 @@
         else
         {
             dv->intr_urb = rxintr;
+            dv->intr_buf = buf;
         }
     }
     else
@@ -1164,7 +1192,7 @@
         printk(PRNPREFIX "Rx INTR alloc error, code %d\n", err);
         if(rxintr)
         {
-            pfree(rxintr);
+            usb_free_urb(rxintr);
         }
         if(buf)
         {
@@ -1239,6 +1267,7 @@
         else
         {
             dv->bulk_urb[number] = rxbulk;
+            dv->bulk_buf[number] = buf;
         }
     }
     else
@@ -1246,7 +1275,7 @@
         printk(PRNPREFIX "Rx BULK alloc error, code %d\n", err);
         if(rxbulk)
         {
-            pfree(rxbulk);
+            usb_free_urb(rxbulk);
         }
         if(buf)
         {
@@ -1392,9 +1421,10 @@
 #endif        
     }
 
-    DBG_PRINT("Listen loop started, code %i\n", res);
+    printk("Listen loop started, code %i\n", res);
 }
 
+#ifdef CSR_BR_USB_USE_SCO_INTF
 /*************************************************************
  * NAME:
  *      handleIsocInEndpoint
@@ -1467,6 +1497,7 @@
             dv->minor, dv->isoc_out_interval, dv->isoc_out_size);
     }
 }
+#endif
 /*************************************************************
  * NAME:
  *      handleBulkInEndpoint
@@ -1577,9 +1608,11 @@
     int alt;
     int devno;
     bool res;
+    const struct usb_device_id *pDevMatch;
 
     struct usb_device *uDev = interface_to_usbdev(intf);
     unsigned int ifnum;
+    printk(PRNPREFIX "enter csrUsbProbe.\n");
 
     /* Look up a free slot. */
     devno = csrSlotFromUsb(NULL);
@@ -1590,9 +1623,24 @@
         return 0;
     }
 
+    /* Do FW upgrade only for QCOM chips */
+    if ( !(id->driver_info) )
+    {
+        pDevMatch = usb_match_id(intf, fw_update_device_table);
+
+        if( pDevMatch )
+        {
+            if( pDevMatch->driver_info & BTUSB_ATH3012 )
+            {
+                btusb_firmware_upgrade(uDev);
+            }
+        }
+    }
+
     
     dv = csr_dev[devno] = zpmalloc(sizeof(*dv));
-	
+	memset(dv,0x0,sizeof(*dv));
+
     /* Lock device and release device list lock. */
     init_MUTEX_LOCKED(&dv->devlock);
     dv->dev = uDev;
@@ -1661,7 +1709,7 @@
     /* The control endpoint is mandatory for all usb devices,
        and can therefore be setup statically */
     dv->ctrl_ep = USB_ENDPOINT_XFER_CONTROL;
-        printk("bt_usb%u: Control endpoint set \n", devno);
+	printk("bt_usb%u: Control endpoint set \n", devno);
 
     /* Scan HCI/ACL interface for endpoints */
     for (alt = 0; alt < intf->num_altsetting; alt++)
@@ -1732,6 +1780,7 @@
             }
         }
     }
+#ifdef CSR_BR_USB_USE_SCO_INTF
     /* Scan SCO interface for endpoints */
     for (alt = 0; alt < sco_intf->num_altsetting; alt++)
     {
@@ -1787,46 +1836,49 @@
             }
         }
     }
+#endif
 #ifdef CSR_BR_USB_USE_DFU_INTF
-	if(dfu_intf != NULL)
-	{
-		/* Scan DFU interface for endpoints */
-		for (alt = 0; alt < dfu_intf->num_altsetting; alt++)
-		{
-			struct usb_interface_descriptor *ifaceDesc;
-			struct usb_host_interface *host;
-
-			host = &(dfu_intf->altsetting[alt]);
-			ifaceDesc = &(host->desc);
-			ifnum = ifaceDesc->bInterfaceNumber;
-
-			/* Detect DFU interface */
-			if ((ifaceDesc->bNumEndpoints == 0) &&
-			   (ifaceDesc->bInterfaceClass == DFU_IFACE_CLASS) &&
-			   (ifaceDesc->bInterfaceSubClass == DFU_IFACE_SUB_CLASS) &&
-			   (ifaceDesc->bInterfaceProtocol == DFU_IFACE_PROTOCOL))
-			{
-				if (!test_bit(DFU_READY, &dv->endpoint_present))
-				{
-					handleDfuInterface(dv, ifnum);
-				}
-			}
-			else
-			{
-				printk("bt_usb%u: no valid DFU interface found\n", devno);
-			}
-		}
-	}
+    if(dfu_intf != NULL)
+    {
+        /* Scan DFU interface for endpoints */
+        for (alt = 0; alt < dfu_intf->num_altsetting; alt++)
+        {
+            struct usb_interface_descriptor *ifaceDesc;
+            struct usb_host_interface *host;
+
+            host = &(dfu_intf->altsetting[alt]);
+            ifaceDesc = &(host->desc);
+            ifnum = ifaceDesc->bInterfaceNumber;
+
+            /* Detect DFU interface */
+            if ((ifaceDesc->bNumEndpoints == 0) &&
+               (ifaceDesc->bInterfaceClass == DFU_IFACE_CLASS) &&
+               (ifaceDesc->bInterfaceSubClass == DFU_IFACE_SUB_CLASS) &&
+               (ifaceDesc->bInterfaceProtocol == DFU_IFACE_PROTOCOL))
+            {
+                if (!test_bit(DFU_READY, &dv->endpoint_present))
+                {
+                    handleDfuInterface(dv, ifnum);
+                }
+            }
+            else
+            {
+                printk("bt_usb%u: no valid DFU interface found\n", devno);
+            }
+        }
+    }
 #endif /*CSR_BR_USB_USE_DFU_INTF*/	
 #ifdef CONFIG_USB_SUSPEND
-	//usb_enable_autosuspend(uDev);
-	//intf->needs_remote_wakeup = 1;
+    //usb_enable_autosuspend(uDev);
+    //intf->needs_remote_wakeup = 1;
 #endif
 
     if (test_bit(BULK_IN_READY, &dv->endpoint_present) &&
        test_bit(BULK_OUT_READY, &dv->endpoint_present) &&
+#ifdef CSR_BR_USB_USE_SCO_INTF
        test_bit(ISOC_OUT_READY, &dv->endpoint_present) &&
        test_bit(ISOC_IN_READY, &dv->endpoint_present) &&
+#endif
        test_bit(INTR_IN_READY, &dv->endpoint_present) &&
        !test_bit(LISTEN_STARTED, &(dv->flags)))
     {
@@ -1834,11 +1886,11 @@
        set_bit(DEVICE_CONNECTED, &(dv->flags)); 
        startListen(dv);
 
-        DBG_PRINT("creating readerThread\n");
+        printk(KERN_ERR "creating readerThread\n");
         /* Start the reader thread */
         // victor change: kernel_thread is not supported in kernel
         //kernel_thread(readerThread, dv, 0);
-	kthread_run(readerThread, dv, "bt_usb%u", dv->minor);
+        kthread_run(readerThread, dv, "bt_usb%u", dv->minor);
     }
 
     /*
@@ -1846,11 +1898,13 @@
      * reader thread can start.
      */
     up(&dv->devlock);
-
+    device_init_wakeup(&(uDev->dev),1);
+    printk(PRNPREFIX "bt_usb%u: device_init_wakeup is done\n",devno);
     return 0;
 }
 
 #ifdef CONFIG_USB_SUSPEND
+
 int csrUsbSuspend(struct usb_interface *intf, pm_message_t state)
 {
     int devno;
@@ -1858,7 +1912,7 @@
 
     struct usb_device *uDev = interface_to_usbdev(intf);
 
-	devno = csrSlotFromUsb(uDev);
+    devno = csrSlotFromUsb(uDev);
     if (devno == -1)
     {
         /*
@@ -1876,25 +1930,26 @@
 
     up(&csr_dev_sem); /* XXX keep? */
 
-	if(intf->pm_usage_cnt.counter > 0)
-	{
-		printk("bt_usb%u: attempt to suspend (PM message: 0x%04x) - busy\n", devno, state.event);
-		return -EBUSY;
-	}
+    if(intf->pm_usage_cnt.counter > 0)
+    {
+        printk("bt_usb%u: attempt to suspend (PM message: 0x%04x) - busy\n", devno, state.event);
+        return -EBUSY;
+    }
 
-	if(test_bit(DEVICE_SUSPENDED, &(dv->flags)))
-	{
-		printk("bt_usb%u: already suspended\n", devno);
-		return 0;
-	}
+    if(test_bit(DEVICE_SUSPENDED, &(dv->flags)))
+    {
+        printk("bt_usb%u: already suspended\n", devno);
+        return 0;
+    }
 
-	set_bit(DEVICE_SUSPENDED, &(dv->flags));
+    set_bit(DEVICE_SUSPENDED, &(dv->flags));
 
     usbCleanUrbs(dv);
 
 	printk("bt_usb%u: went to suspend (PM message: 0x%04x)\n", devno, state.event);
 
-	return 0;
+
+    return 0;
 }
 
 int csrUsbResume(struct usb_interface *intf)
diff -Nur bt_usb_driver/usb_intf.c bt_usb_driver-new/usb_intf.c
--- bt_usb_driver/usb_intf.c	2016-01-09 09:20:05.000000000 +0800
+++ bt_usb_driver-new/usb_intf.c	2019-04-09 16:53:46.125032909 +0800
@@ -162,6 +162,7 @@
         }
     }
 
+	printk("%s: Exit\n",__func__);
     /* Done */
     clear_bit(R_THREAD_RUNNING, &(dv->flags));
     complete_and_exit(&dv->reader_thread_exit, 0);
@@ -461,6 +462,11 @@
     struct usb_qe *qe;
 
     dv = devLookup(devno);
+	if(dv == NULL)
+	{
+		printk("%s: Device not initialized\n",__func__);
+		return;
+	}
 
     if((atomic_read(&(dv->queue.count)) > 0 ) &&
        test_bit(DEVICE_CONNECTED, &(dv->flags)))
@@ -564,6 +570,12 @@
     printk(PRNPREFIX "Resetting USB device..\n");
 
     dv = devLookup(devno);
+	if(dv == NULL)
+	{
+		printk("%s: Device not initialized\n",__func__);
+		return;
+	}
+
     usb_reset_device(dv->dev);
 
     up(&dv->devlock);
